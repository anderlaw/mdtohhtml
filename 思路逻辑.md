### js中创建对象的三种方式
js高级第一天都是围绕一个核心展开的，这个核心的就是原型。但是原型跟js中的对象联系非常的紧密，所以咱们先
从对象说起。

回忆一下，js中创建对象的几种方式：

- new Object().一般创建空对象，需要属性或方法的话需要手动去添加，这样显的不太方便。
- 对象字面量。在创建对象的时候就给对象设置好了属性或方法，非常方法。如果需要批量创建对象，需要重复
写这些代码，非常的繁琐。
- 工厂函数。

好，掌握的都还不错哦。接下来咱们观察一下这三种方式创建的对象，看看有啥特点。

都是Object类型。就是说我们通过以上三种方式创建的任何对象都是Object类型的，我们知道，工作中需要我们创建
各式各样的对象，比如一个人的对象，一个狗的对象，但是用以上三种方式创建，你会发现无论是人对象还是狗对象都是Object类型吧？
人和狗就一样了呗？不行
我们创建人这个对象应该是Person类型，狗应该是Dog类型，学生呢应该是Student类型吧？

这种情形下，应该怎么做呢？介绍一种新的方式：通过自定义构造函数创建对象。

### 自定义构造函数创建对象（三个要点）
什么是构造函数呢？就是一个函数。

js中提供了很多内置的对象，比如：Object,Date,Array.他们既是对象也是构造函数。
var obj1 = new Object();//obj1是Object的实例
var date = new Date();//date是Date的实例
var arr = new Array();//arr是Array的实例。

通过构造函数new出来的对象是实例。
观察发现有啥特点呢？口述，构造函数的函数名首字母应该是大写，须搭配new 来创建对象。

总结：

- 是个函数，
- 首字母大写
- 搭配new使用。

什么是自定义构造函数呢?就是不是js内部提供的，而是我们自己写的构造函数。如何写？参考两点。
function Person(){}
var obj = new Person();//obj是不是Person构造函数new处出来的对象呢？是不是实例啊？
console.log(obj);//打开页面发现，对象有没有类型呢？

---------------------

目的达到了吧？但是得知道这个对象是哪来的？new做的三件事：1.2.3

现在对象是空的吧？大多情况下我们对象应该有属性吧？如何添加属性呢？new做了几件事呢?......

总结一下，new 负责了三件事。。。。。， 然后构造函数是不是负责了一件事，给对象添加属性和方法。各司其职。

练习：创建一个狗（DOg）构造函数，狗有品种和性别，年龄，可以叫。

### 自定义构造函数的优点和缺点
优点是啥：创建的对象有类型，非常方便地批量创建对象。（新建构造函数，创建两个对象...，演示“对象的类型”和“批量”）
有没有缺点呢？

说缺点之前，我先问大家个问题，p1是个实例吧？这里是不是给每个实例添加了一个sayHi的方法吧？p1有没有这个方法？p2呢？而且，
p1和p2的saiHi方法其实干的事是一样的，应该是一样的才好。p1.sayHi。。。p1.sayHi  ===  p2.sayHi //false; 返回false意味着不相等的吧？

创建了2个对象（实例），每个实例都有一个sayHi。如果创建了84个对象，你告诉我有几个sayHi方法，84个。

问题在于这84方法功能是一样的，但是写了84次，每个方法都会占用内存，这样就导致了内存浪费。

缺点是内存浪费。
### js中的三等号
两种相等运算符：
==；//比较时会进行类型转换。
===;//不会进行类型转换。

基本类型：比较类型和值。
1===1

'123' === '123';
引用类型：比较内存的地址，只要内存地址不同就不同（不管你类型不类型的。我不管）
console.log(new Array() === new Array())
[] === [];//[]相当于 new Array，new是不是会创建一个新的对象啊？这个对象是Arraynew出来的吧？是Array的实例。右边也创建了一个新的Array的实例。
一个妈妈刚生了双胞胎，一对女孩。虽然都是一个妈生的都是女孩，但是同一个人吗？
console.log(new Object() === new Object())
{} === {}//相当于new Object();//。。

function(){} === function(){};//相当于new Function("console.log('大家好')");。。。。

虽然都是一类实例对象，但是还是不等的吧，比如你弟兄俩，你跟你弟弟是两人吧？


### 图解分析自定义构造函数的内存浪费
（图上有构造函数，匿名函数。左右结构。）

解释new负责的事情，还有构造函数负责的事情（p1实例为例说明，图上标明对象的属性和方法），然后p2同样的事情。。。。

为什么会内存浪费呢？

每个对象，也就是每个实例设置方法时，都设置了一个新的匿名函数（Function的实例）。都是匿名函数，
但是占据的内存地址是不同的，功能是一样，但是每个匿名函数都占用了内存，这样就导致了内存浪费。

### 命名函数解决内存浪费问题
复述原因

想节省内存，其实说白了，让不同实例去共享一个sayHi吧？共享wifi用过吧？我这边开个热点，
一群人过来蹭。


演示怎么办：首先声明一个函数 ，其次所有的实例都指向这个命名函数就行了吧？

演示比较相等了。

有其他方法呢？整合到一个对象里，有其他构造函数呢，额外创建很多对象呢？

现在用以前学过的知识，我们已经黔驴技穷了。怎么办呢？

### 原型对象(三点)
/*
1.任何函数都有一个prototype属性，包括构造函数
2.这个prototype属性指向一个对象，称为原型对象。
3.任何构造函数new出来的对象（专业名词：实例）都可以访问原型对象上的属性或方法。
*/

演示普通函数和构造函数，打印本身展示prototype属性

演示并打印其prototype属性，验证是个对象。

原型对象是不是个对象呢？如何给原型对象这个对象添加属性和方法？
Person.prototype.money = '40亿美元';//来点前
来个豪车
Person.prototype.car = 'BMW';//
Person.prototype.sayHi = function(){
	console.log('大家好');
}

构建实例p1,打印发现是空对象，p1上有没有money属性呢？什么属性都没得。

console.log(p1.money);//有

为啥？p1是不是Person的实例，money是不是Person原型对象上的属性，实例可以访问原型上的属性和方法的。

还有car,还能访问方法呢。。。。


总结一下：三个关键的东西,构造函数，实例，原型对象。

接下来花个图帮助理解

### 图解三角关系
孩子，爸爸，妈妈。

原型对象讲完了，有同学会问，有啥用呢？注意我们还遗留了一个问题吧。。。

### 原型对象解决内存浪费问题（一点）

复述并写一遍内存浪费的前因后果（新写一个构造函数。。。p1.sayHi === p2.sayHi）


原型如何解决这个内存浪费问题呢？推荐把所有的功能相同的方法写到原型对象上。
Person.prototype.sayHi = function(){ console.log(‘大家好！’) }

p1是不是Person的实例，可不可以访问原型对象上的sayHi方法？演示。p2.。。。。。。

最后p1.sayHi === p2.sayHi；//true，意味着实例之间共享了一个sayHi方法，是不是就节省内存了呢？

总结原型对象的作用是啥呢：存放供实例调用的公共方法，节省内存空间。

### 图解实例如何访问原型对象上的方法
。。。。。

### __proto__属性（三点：1.__proto__ ,2.同一个对象。3.方便查看原型对象，）
复述三角关系

任何实例都有__proto__属性，演示这个属性，给对象添加一个属性，再演示，发现__proto__颜色
跟普通属性不同，说明这个__proto__比较特殊

__proto__也指向原型对象，这里的原型对象跟我们刚刚讲过的原型是同一个对象。

总结一下学过的两种访问原型的方法；1.person.prototype === p1.__proto //true;2.。。。

console.log(p1.__proto__ === p2.__proto__);//
画个图解释一下。

解释有何用，可以方便地查看孩子的父亲。演示。。var arr = []; arr.__proto

这个属性前面有__，表示是私有属性，不要修改。IE6,7,8,9,10上不支持。

举例。。添加原型方法，。。

### constructor属性
1.每个原型对象上天生具有一个属性constructor,并演示
2.这个constructor指向构造函数，演示

画个图。。。。

测试题：
Person.prototype.constructor === Person
p1.constructor === Person.prototype.constructor
p1.constructor === Person



### 原型链的绘制
写构造函数，实例，p1是不是实例，有妈妈和爸爸吧？ 爸爸是原型对象吧？爸爸有妈妈没，有爸爸没？。。

一个实例是个对象，对象就会有原型对象（__proto__）,原型对象本身也是一个对象也会有自己的原型对象（__proto__）
多个原型对象组成的链式结构叫原型链。画图

原型链有啥用呢？举个例子：Person,p1,p1是个空对象吧？我们有没有给原型对象上添加属性和方法呢？没有。p1.toString。打印发现
有吧？它自己没有，它爹也没有，从哪来的呢？从它爷爷身上来的。找找看：p1.__proto__.__proto__，也就是说实例不仅可以访问爸爸的属性和方法
也能访问爷爷的方法？其实啊，只要是这个链上的方法都能访问。所以原型链重要吗？

接下来我们来画一下原型链Person

演示实例与爸爸妈妈，爷爷奶奶。。。。

### 其他对象的原型链
数组：var arr = new Array();
arr ---> Array.prototype --->Object.prototype ---> null

var d = new Date();
d ---> Date.prototype ---> Object.prototype ---> null

var div = document.querySelector('div');
//如何给div注册事件监听？
div.addEventListener('')，div能调用addEventListener想过为啥能调用？

div.__proto__.__proto__.__proto__,找addEventListener


### 属性访问原则
当访问一个对象的某个属性时：
1.直接在对象本身上查找是否有这个，如果有就返回。
2.如果没有，会去对象的原型中查找是否有这个属性，如果有几返回
3.如果没哟，沿着原型链，一直找到Object.prototype中，如果有找到返回
4.如果都没有，返回undefined。

如果有钱 自己的钱，画爸爸的钱。。。。真的没钱了。

注意这块在面试中一般都会问的。
比如：
function Person(name){
	this.name = name;
}
Person.prototype.name = '学生'
Person.prototype.money = '100亿'；

var p1 = new Person('副班长');
console.log(p1.name);
console.log(p1.money);
### 属性搜索原则练习题
function Person(name){
	this.name = name;
}
Person.prototype.name = '学生'
Person.prototype.money = '100亿'；

var p1 = new Person();
console.log(p1.name);
console.log(p1.money);

---------更改
function Person(name){
	if(name){
		this.name = name;
	}
	
}
### 对象的设置原则
obj.name = '嘻嘻';
//1.如果对象有这个属性，直接修改这个属性。
2.如果对象没有这个属性，直接添加这个属性
3.给对象设置属性不影响原型链。


function Person(name){
this.name = name;
}
Person.prototype.name = '人
Person.prototype.money = 100;

var p = new Person('班长');
console.log(p)

//修改自己的属性和原型链上的属性。
p.name = '副班长'
p.money = 200;

console.log(p)

console.log(Person.prototype)


//测试题
function Person(){}

var p = new Person();
Person.prototype.money = 200;

console.log(p.money);
p.money = 300;

console.log(p.money)

console.log(Person.prototype.money)

